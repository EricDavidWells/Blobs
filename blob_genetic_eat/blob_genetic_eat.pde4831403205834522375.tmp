import org.jblas.*;
import org.jblas.exceptions.*;
import org.jblas.util.*;
import org.jblas.benchmark.*;
import org.jblas.ranges.*;

int pop_no = 40;
int food_no = 20;
float food_energy = 20;
ArrayList<Food> foods;
Population blobs;

// genetic variables
int d_inputs_n = 2;    // number of distance regions
int a_inputs_n = 8;    // number of angle regions
float sp_max = 20;    // max speed for all blobs, actual speed is sp_max/r
float r_start = 10;    // radius to start blobs at
float vis_mult = 3;    // number to multiply radius by to get vision range
float move_decay_rate = 0.05;   // rate at which blobs decay
float age_decay_rate = 0.000001;
float mutation_rate = 0.025;

void setup() {
  
  // initialize size of window
  size(1000,700);
  
  blobs = new Population();
  
  // initialize blobs into population class
  for (int i = 0; i<pop_no; i++){
    Blob blob = new Blob(r_start, sp_max, vis_mult, d_inputs_n, a_inputs_n, "NN");
    blob.randomize();
    blob.rebuild();
    blobs.individuals.add(blob);
  }
  
  // initialize foods into arraylist object
  foods = new ArrayList<Food>();
  for (int i = 0; i<food_no; i++){
    Food food = new Food(color(random(10, 255), random(10, 255), random(10, 255), 50), 2.5, random(0, width), random(0, height), food_energy);
    foods.add(food);
  }

}

void draw() {
  background(0);

  // display food outside of blob loop
  for (int i = foods.size()-1; i>=0; i--){
    Food food = foods.get(i);
    food.display();
  }
  
  // display all blobs
  blobs.display();
  // drive all blobs
  blobs.drive();
  // check all collisions
  blobs.check_collisions();
  // evaluate fitness
  blobs.evaluate_fitness();
  // selection and reproduction
  blobs.reproduce();
    
  fill(255);
  text("blobs left: " + str(blobs.individuals.size()), width/2, height/2);
  text("foods left: " + str(foods.size()), width/2, height/2-12);
  
}

class Blob {

  color c;  // color
  float r;  // radius
  float sp;  // speed
  float sp_max;  // max speed
  String name;  // name
  PVector pos;  // position
  PVector vel;  // velocity
  float vis_r;  // vision radius
  float vis_mult;
  float[] d_inputs;  // number of distance input neurons
  float[] a_inputs;  // number of angular input neurons
  float[] NN_blob_input;  // input for blob vision
  float[] NN_food_input;  // input for food vision
  float[] NN_wall_input;  // input for wall vision
  String dr_mode;  // drive mode
  int[] sizes = new int[3];
  float[] chromosome;
  ArrayList<org.jblas.FloatMatrix> weights = new ArrayList<org.jblas.FloatMatrix>();
  ArrayList<org.jblas.FloatMatrix> biases = new ArrayList<org.jblas.FloatMatrix>();
  float max_r;
  float birthday;
  float age;
  float fitness;
  org.jblas.FloatMatrix output;

  Blob(float r_start, float sp_max_, float vis_mult_, int d_inputs_n, int a_inputs_n, String dr_mode_){
    c = 0;
    r = r_start;
    sp_max = sp_max_;
    sp = sp_max/r;
    name = "blob";
    pos = new PVector(random(width), random(height));
    vel = new PVector(0, 0);
    vis_mult = vis_mult_;
    vis_r = r*vis_mult_;
    max_r = 0;
    birthday = millis();
    age = 0;
    d_inputs = new float[d_inputs_n];
    a_inputs = new float[a_inputs_n];
    NN_blob_input = new float[d_inputs_n*a_inputs_n];
    NN_food_input = new float[d_inputs_n*a_inputs_n];
    NN_wall_input = new float[d_inputs_n*a_inputs_n];
    dr_mode = dr_mode_;
    sizes[0] = d_inputs_n*a_inputs_n*3;
    sizes[1] = 8;
    sizes[2] = 4;
    chromosome = new float[((sizes[1] + sizes[2]) + (sizes[0]*sizes[1] + sizes[1]*sizes[2])) + 3];
    output = org.jblas.FloatMatrix.zeros(4);
}
  
  void display() {
    
    // display vision circle
    stroke(red(c), green(c), blue(c), 20);
    fill(red(c), green(c), blue(c), 20);
    ellipse(pos.x, pos.y, r*vis_mult*2, r*vis_mult*2);
    
    // display body
    stroke(c);
    fill(c);
    ellipse(pos.x, pos.y, 2*r, 2*r);
    

    // display NN output values
    //stroke(255);
    //fill(255);
    //text(str(output.get(0)), pos.x, pos.y+24);
    //text(str(output.get(1)), pos.x, pos.y+12);
    //text(str(output.get(2)), pos.x, pos.y);
    //text(str(output.get(3)), pos.x, pos.y-12);

  }

  void drive() {
    
    vis_r = vis_mult*r;
    sp = sp_max/r;
    
    if (dr_mode == "brownian"){
    // random brownian movement
    vel.x += random(-1, 1)*sp;
    vel.y += random(-1, 1)*sp;
      
    // limit speed
    vel.x = constrain(vel.x, -sp, sp);
    vel.y = constrain(vel.y, -sp, sp);
    
    // update position
    pos.add(vel);
    }
    else if (dr_mode == "mouse"){
      // follow mouse movement
      pos.x = pos.x*(100-sp)/100 + float(mouseX)*sp/100;
      pos.y = pos.y*(100-sp)/100 + float(mouseY)*sp/100; 
    }
    else if (dr_mode == "NN"){
      // use neural net to drive blob
      org.jblas.FloatMatrix input = new org.jblas.FloatMatrix(concat(concat(NN_blob_input, NN_food_input), NN_wall_input));
      output = feed_forward(weights, biases, input);
      
      //vel.x += sp*(output.get(0) - output.get(1));
      //vel.y += sp*(output.get(2) - output.get(3));
      //vel.x = constrain(vel.x, -sp, sp);
      //vel.y = constrain(vel.y, -sp, sp);
      
      vel.x = sp*(output.get(0) - output.get(1));
      vel.y = sp*(output.get(2) - output.get(3));
      vel.x = constrain(vel.x, -sp, sp);
      vel.y = constrain(vel.y, -sp, sp);
           
      pos.add(vel);
      
      for (int i = 0; i<NN_blob_input.length; i++){
        NN_blob_input[i] = 0; 
      }
      for (int i = 0; i<NN_food_input.length; i++){
        NN_food_input[i] = 0; 
      }
      for (int i = 0; i<NN_wall_input.length; i++){
        NN_wall_input[i] = 0; 
      }
      
    }
    
    max_r = max(max_r, r);
    age += (millis()-birthday); 

    float decay_amount = max(sqrt((pow(vel.x, 2) + pow(vel.y, 2)))/sp*move_decay_rate, (age/1000)*age_decay_rate);
    r = max(0, r-decay_amount);
    if (r<2.5){
      r = 0;
    }
  }
  
  void check_wall_collision(){
    // check if collision with edges of screen and adjust position to not exceed it
    
    if (pos.x > width-r) {
      pos.x = width-r;
      vel.x *= -0.5;
      } 
    if (pos.x < r) {
      pos.x = r;
      vel.x *= -0.5;
      } 
    if (pos.y > height-r) {
      pos.y = height-r;
      vel.y *= -0.5;
      } 
    if (pos.y < r) {
      pos.y = r;
      vel.y *= -0.5;
    }
      
    stroke(255);
    fill(255);  
    // check vision collision
    if (pos.x > width-vis_r) {
      float dist_normal = abs(width-pos.x)/vis_r; //<>//
      int dist_region = int(dist_normal*d_inputs.length);
      float angle = atan2(0, -(width-pos.x)) + PI;
      float angle_normal = min(angle/TWO_PI, 0.99);
      int angle_region = int(angle_normal*a_inputs.length);
      float angle_rounded = angle_region*TWO_PI/a_inputs.length + PI/a_inputs.length;
      int NN_wall_index = dist_region * a_inputs.length + angle_region;
      NN_wall_input[NN_wall_index] = 1;
      //text(str(NN_wall_index), pos.x, pos.y);
      } 
    if (pos.x < vis_r) {
      float dist_normal = abs(pos.x)/vis_r;
      int dist_region = int(dist_normal*d_inputs.length);
      float angle = atan2(0, -(-pos.x)) + PI;
      float angle_normal = min(angle/TWO_PI, 0.99);
      int angle_region = int(angle_normal*a_inputs.length);
      float angle_rounded = angle_region*TWO_PI/a_inputs.length + PI/a_inputs.length;
      int NN_wall_index = dist_region * a_inputs.length + angle_region;
      NN_wall_input[NN_wall_index] = 1;
      //text(str(NN_wall_index), pos.x, pos.y);
      }
    if (pos.y > height-vis_r) {
      float dist_normal = abs(height-pos.y)/vis_r;
      int dist_region = int(dist_normal*d_inputs.length);
      float angle = atan2(height-pos.y, 0) + PI;
      float angle_normal = min(angle/TWO_PI, 0.99);
      int angle_region = int(angle_normal*a_inputs.length);
      float angle_rounded = angle_region*TWO_PI/a_inputs.length + PI/a_inputs.length;
      int NN_wall_index = dist_region * a_inputs.length + angle_region;
      NN_wall_input[NN_wall_index] = 1;
      //text(str(NN_wall_index), pos.x, pos.y);
    } 
    if (pos.y < vis_r) {
      float dist_normal = abs(pos.y)/vis_r;
      int dist_region = int(dist_normal*d_inputs.length);
      float angle = atan2(-pos.y, 0) + PI;
      float angle_normal = min(angle/TWO_PI, 0.99);
      int angle_region = int(angle_normal*a_inputs.length);
      float angle_rounded = angle_region*TWO_PI/a_inputs.length + PI/a_inputs.length;
      int NN_wall_index = dist_region * a_inputs.length + angle_region;
      NN_wall_input[NN_wall_index] = 1;
      //text(str(NN_wall_index), pos.x, pos.y);
    }
  }
    
    
    
  void check_blob_collision(Blob other_blob){
    // check collision with another blob as well as collision of vision with another blob
    
    // check body collision
    if (pos.dist(other_blob.pos) < (r + other_blob.r)){
        
      if (r < other_blob.r){
        other_blob.r = sqrt(pow(other_blob.r, 2) + pow(r, 2));
        r = 0;
      }
      else if (r > other_blob.r){
       r = sqrt(pow(other_blob.r, 2) + pow(r, 2));  
       other_blob.r = 0;
      } 
    }
    
    // check vision collision
    if (pos.dist(other_blob.pos) < (vis_r + other_blob.r)){
      
      float dist = abs(pos.dist(other_blob.pos) - other_blob.r);
      float dist_normal = min(dist/vis_r, 0.99);
      int dist_region = int(dist_normal*d_inputs.length);
      float angle = atan2((other_blob.pos.y-pos.y), -(other_blob.pos.x-pos.x)) + PI;
      float angle_normal = min(angle/TWO_PI, 0.99);
      int angle_region = int(angle_normal*a_inputs.length);
      float angle_rounded = angle_region*TWO_PI/a_inputs.length + PI/a_inputs.length;
      
      int NN_blob_index = dist_region * a_inputs.length + angle_region;
      NN_blob_input[NN_blob_index] = r-other_blob.r;
      
      stroke(255);
      fill(255);
      //line(pos.x, pos.y, pos.x + cos(angle_rounded)*r, pos.y - sin(angle_rounded)*r);
      line(pos.x, pos.y, pos.x + cos(angle)*r, pos.y - sin(angle)*r);
      //text(str(NN_blob_index), pos.x, pos.y);
      
    }
    
    if (pos.dist(other_blob.pos) < (r + other_blob.vis_r)){
     
      float dist = abs(other_blob.pos.dist(pos) - r);
      float dist_normal = min(dist/other_blob.vis_r, 0.99);
      int dist_region = int(dist_normal*other_blob.d_inputs.length);
      float angle = atan2((pos.y-other_blob.pos.y), -(pos.x-other_blob.pos.x)) + PI;
      float angle_normal = min(angle/TWO_PI, 0.99);
      int angle_region = int(angle_normal*other_blob.a_inputs.length);
      float angle_rounded = angle_region*TWO_PI/other_blob.a_inputs.length + PI/other_blob.a_inputs.length;
      
      int NN_blob_index = dist_region * other_blob.a_inputs.length + angle_region;
      other_blob.NN_blob_input[NN_blob_index] = other_blob.r-r;
      
      stroke(255);
      fill(255); 
      //line(other_blob.pos.x, other_blob.pos.y, other_blob.pos.x + cos(angle_rounded)*other_blob.r, other_blob.pos.y - sin(angle_rounded)*other_blob.r);
      line(other_blob.pos.x, other_blob.pos.y, other_blob.pos.x + cos(angle)*other_blob.r, other_blob.pos.y - sin(angle)*other_blob.r); 
      //text(str(NN_blob_index), other_blob.pos.x, other_blob.pos.y);  
  }
    
    
  }
  
  void check_food_collision(Food food){
    
    // check collision with blob
    if (pos.dist(food.pos) < (r + food.r)){
      if (r > food.r){
       r = sqrt(pow(food.energy, 2) + pow(r, 2));
       food.r = 0;
      }
    }
    
    // check collision with blob vision
    if (pos.dist(food.pos) < (vis_r + food.r)){

      float dist = abs(pos.dist(food.pos) - food.r);
      float dist_normal = min(dist/vis_r, 0.99);
      int dist_region = int(dist_normal*d_inputs.length);
      float angle = atan2((food.pos.y-pos.y), -(food.pos.x-pos.x)) + PI;
      float angle_normal = min(angle/TWO_PI, 0.99);
      int angle_region = int(angle_normal*a_inputs.length);
      float angle_rounded = angle_region*TWO_PI/a_inputs.length + PI/a_inputs.length;
      
      int NN_food_index = dist_region * a_inputs.length + angle_region;
      NN_food_input[NN_food_index] = food.energy;
      
      stroke(200, 100, 100);
      fill(255);
      line(pos.x, pos.y, pos.x + cos(angle)*r, pos.y - sin(angle)*r);
      //text(NN_food_index, pos.x, pos.y);
    }
  }
  
  void randomize(){
    // randomize chromosome
    int c_index = 0;
    for (int i = 0; i<(sizes[1] + sizes[2]) + (sizes[0]*sizes[1] + sizes[1]*sizes[2]); i++){
      chromosome[i] = random(-2, 2); 
      c_index += 1;
    }
    chromosome[c_index] = random(0, 255);
    chromosome[c_index + 1] = random(0, 255);
    chromosome[c_index + 2] = random(0, 255);
    c_index += 3;
    
  }
  
  void rebuild(){
    // rebuild attributes with new chromosome
    int c_index = 0;
    for (int i=1; i<sizes.length; i++){  // for each hidden layer and output layer 
    // add a column matrix of length of current layer to biases array list
    biases.add(new org.jblas.FloatMatrix(subset(chromosome, c_index, sizes[i]))); 
    // update chromosome index
    c_index += sizes[i];
  }
  
  // create weights arraylist of matrices from chromosome
  for (int i=1; i<sizes.length; i++){  // for each hidden layer and output layer
    // create temporary empty weight matrix with # of rows = length of current layer and # of columns = length of previous layer
    int rows = sizes[i];
    int cols = sizes[i-1];
    org.jblas.FloatMatrix w = new org.jblas.FloatMatrix(new float[rows][cols]);  
    for (int j=0; j<rows; j++){  // for each row in weight matrix
      // add a row onto the weight matrix from chromosome
      w.putRow(j, new org.jblas.FloatMatrix(subset(chromosome, c_index, cols)));
      // update chromosome index
      c_index += cols;
    }
    // add weight matrix into the weights array list
    weights.add(w);
  }
    
    c = color(chromosome[c_index], chromosome[c_index+1], chromosome[c_index+2]);
    c_index += 3;
  }
}

void mousePressed(){
  Blob mouseblob = new Blob(r_start, sp_max, vis_mult, d_inputs_n, a_inputs_n, "mouse");
  mouseblob.randomize();
  mouseblob.rebuild();
  mouseblob.r = 10;
  mouseblob.sp_max = 1000;
  mouseblob.sp = mouseblob.sp_max/mouseblob.r;
  mouseblob.pos.x = mouseX;
  mouseblob.pos.y = mouseY;
  blobs.individuals.add(mouseblob); 
}

void keyPressed(){

}

org.jblas.FloatMatrix feed_forward(ArrayList<org.jblas.FloatMatrix> weights_, ArrayList<org.jblas.FloatMatrix> biases_, org.jblas.FloatMatrix input_ ){
  org.jblas.FloatMatrix output;
  
  // feed forward through first layer
  output = weights_.get(0).mmul(input_);
  output = output.add(biases_.get(0));
  // apply activation function
  for (int i = 0; i < output.length; i++){
    output.put(i, sigmoid_neuron(output.get(i)));
  }
  
  // feed forward through rest of layers
  for (int i = 1; i < weights_.size(); i++){
     output = weights_.get(i).mmul(output);
     output = output.add(biases_.get(i));
     for (int j = 0; j < output.length; j++){
        output.put(j, sigmoid_neuron(output.get(j)));
     }
  }
  
  return output;
}
  
float sigmoid_neuron(float x){
  float y = 1/(1+exp(-x));
  return y;
}
  
float perceptron_neuron(float x){
  float y;
  if (x > 0){
    y = 1;
  }
  else{
    y = 0; 
  }
  return y;
}